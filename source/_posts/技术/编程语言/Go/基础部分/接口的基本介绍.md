---
date: 2021-04-07 06:55:30
updated: 2021-04-07 06:55:30
title: go 接口基本介绍
index_img: /gallery/2021-08-23-21-59-40.png
tags: 
  - Golang

categories:
  -  Golang

---



# go 接口基本介绍

- 因为 go 不是传统的面向对象的语言，在 go 中没有类和继承的概念，但是 go 有接口概念
- 接口的简单理解就是，如果谁可以实现这个事情（在接口中的函数名字 list），那么谁就可以被调用
  - 所以说，接口描述的是，能实现对应事情的普遍方法
  - 下面画了对应的图其中，会叫，和会吃，是两个不同的事情，但是不同类型的数据有不同的方法来实现同样的事情，那么这个时候就会对有相似的方法进行一个归类
  - X 是接口类型，或者是特定的数据结构

![error_loading](/gallery/2021-04-06-20-50-20.png)

---

- 基本的接口实现

```vim
type Namer interface{
    Method1 (parameter_list) return_type
    Method2 (parameter_list) return_type
    ...
}

// 只包含一个方法的接口名字使用 [e]r 来结尾
```

- 接口可以有值， `var in Namer` 其中 in 是个多姿的数据结构，他的值是 `nil` 本质上是个指针
- 实现了 Namer 的接口类型可以赋值给 in ，这个时候，使用 in 来调用接口里面的方法
- [基本的例子](/posts/code/go/接口/基本实例.go)
- 然后对于使用接口，最佳的使用方法就是对接口中的方法，对于不同的数据类型要有实现

# 对于直接传递类型到接口中

- 这个基本语法是`Namer(DataType)`
- 这里相当于直接把特定数据类型的数据套在 **接口** 这个盒子里面
- 然后盒子（可以理解为包装把，因为盒子不会影响对于的数据），但是我之知道盒子可以实现某种功能
- 然后`Namer(DataType)`本身是和数据类型，所以可以存在数组里面，或者传递给 Namer 类型的变量
  - `var empty Namer`
  - `empty = Namer(DataType)`
  - 上面的两个代码就可以实现相应的复制，然后调用`Namer`接口中的方法
- 还有就是用接口数组来存储，然后通过统一的方法来调用
  - [这里是上述的实例](/posts/code/go/接口/接口数据类型.go)
  - 这里主要说明的就是，使用这种方式可以简化代码，这也算是 `多态`的一种实现

# 核心说明

- 接口这个概念主要还是为了减少代码的重复，主要就是，通过同一种调用`Namer.Call()`
- 在保证`Call()`有对应的实现的情况下，直接调用 Call 就可以更具具体的数据类型选择对应的实现方法
- 而不需要去关心那 Namer 位置下的类型，我只知道它可以 Call 这样其实就叫做多态
  - 是一种，不去关心对应的数据到底是什么类型，而去关注它能做什么的一种编写方式

# 接口类型和约定

- 接口类型描述了一系列方法的集合，实现了这些方法的具体类型就是接口类型的实例
- 可以在接口指定方法接受的值和返回数值的类型

```go
package io

type Reader interface{
  Read(p []byte) (n int , err error)
}

type Closer interface{
  Close(p []byte) (n int , err error)
}

// ! 这里说明的是，Reader 方法支持读入任意字节类型的数据
// ! 然后返回一个int 和 错误信息，但是 Read这个方法是需要
// ! 对应传入接口类型传入的，接口只是声明一个包装
```

## 接口嵌套

- 新接口类型可以通过现有接口进行组合
- 有点类似于结构体的嵌套
- [具体实例](/posts/code/go/接口/嵌套接口.go)

## 空接口介绍

- 空接口可以理解为一种可以存储任意类型数据的一种数据
- 因为空接口是没有方法的,所以任意类型的数据都可以实现空接口
  - 因为不需要指定方法,所以也就不需要实现
  - 因为没有实现的要求,也就是任意的数据可以传输到空接口中
- 一个空接口是接收 **一种** 类型的数据,所以不是一个
- [使用实例](/posts/code/go/接口/空接口.go)

## 接口类型判断

- 这里的主要作用就是看看这个`盒子`里面到底是个啥
- 结合之前说的东西，接口主要之作用就是提供多态
- 多态就是，不去关注类型而关注方法，也就是说接口会帮我们隐藏数据类型
- 但是我们还是可以通过`InterFace.(Type)`来查看`InterFace`这个盒子里面是不是`Type`这个东西
- 上面的会返回两个数值`v,ok := InterFace.(Type)`
  - 如果`Interface`里面为`Type`里面的数据,那么`v`为对应的数据
  - 然后`ok`返回 true
- [使用实例](/posts/code/go/接口/接口类型判断.go)
- [函数接收空接口然后判断类型,这个是扩展方法](/posts/code/go/接口/空接口接受多类型数据实现判断.go)

## 关于 类型 与 类型指针 接口实现的问题

- 这里有点类似与 [**方法在指针类型**](/posts/go%E6%96%87%E7%AB%A0/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%96%B9%E6%B3%95/go-method/#%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95) 部分
  - [上面的参考代码](/posts/code/go/函数/方法/指针对象.go)
  - 上面主要是说明 golang 自动的处理指针的意思
- 到接口这里说明的就是,传入到接口中,对于值和对应值的指针的处理问题
- [实例](/posts/code/go/接口/传递指针和值到接口.go)

# 接口的查询

- 这里主要就是处理接口之间的子集的关系的

![error_loading](/gallery/2021-04-07-13-37-47.png)

- [使用实例](/posts/code/go/接口/接口查询.go)

# 接口组合

- 这个部分和接口的嵌套是一致的
- 具体的代码实现可以 [看这里](/posts/code/go/接口/嵌套接口.go)
