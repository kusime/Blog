---

date: 2021-03-29 21:21:21
updated: 2021-03-29 21:21:21
title: go 切片 
index_img: /gallery/2021-08-23-21-59-40.png
tags: 
  - Golang

categories:
  -  Golang

---



# 创建数组切片

### 法 1

- 使用内置函数 make() ，使用这个方式创建的时候需要指定长度和容量

```go
// ! 创建一个字符串切片
slice := make([]string,2,10)
// ! 这里创建的是长度为 2 ， 如果只指定长度的话，长度和容量相等
// ! 容量为10 的字符串切片
```

#### 长度和容量

- 创建出来的底层数组长度就是 创建时的指定容量
  - 这里说的长度是元素个数，不是字节长度
  - 就是对应数据类型的数组的可包含的元素个数
- 但是初始化的时候不可以访问所有的数组元素
  - 只可以访问长度之内的，长度之外，容量之内这个时候访问不了
  - 但是没有被初始化的，之后可以合并到切片里面
- 不可以创建长度大于容量的切片

### 法 2

- 这个使用切片字面量创建切片字面量
- 这里的声明有必要和数组的声明区分一下

```go
slice := []string{"www","ming-cloud","com"}
// ! 这里和数组的区别是，不要在 【】 里面指定切片的长度
// ! 出事的长度和容量会基于初始化的个数来决定
slice := []int{1:99, 2:88}
// ! 这个的部分初始化的语法和数组差不多
```

## 和数组的区别

```go
array := [3]int{1,2,3}
slice := []int{1,2,3}
```

## nil 和空切片

- 声明的时候不做初始化就是空切片
- `var slice []int`
- 这个多用于标准库和内置函数
- 用来描述一个暂时不存在的切片
- 函数要求返回一个切片，但是发生异常的时候
- 可以这样声明
  - `slice := make([]int,0)` 这个使用 make 方法创建空切片
  - `slice := []int{}` 这个使用切片字面量来创建
- nil 切片在底层数组中包含 0 个元素，没有分配任何存储空间
- nil 切片可以调动正常切片可以调动的任何函数
  - append
  - len
  - cap

# 切片的使用

## 分割

- 切片就是把底层数组切出一个部分

```go
// ! 创建一个长度和容量都是 5 的 切片
slice := []int{1,2,3,4,5}
// ! 下面就是直接新建一个切片，长度为2个元素，容量为 4
newSlice := slice[1:3]
newSlice2 := slice[0:3:4]
```

- newSlice 就是感觉有点类似于下面这个图片

![error_loading](/gallery/2021-03-29-22-27-42.png)

- 比如有 slice[i:j:k]
- 长度有 j-i
- 容量为 k-i

![error_loading](/gallery/2021-03-29-22-41-21.png)

## 对切片分割的说明

- 上面两个基于现有切片来创建所谓 “新”的切片其实还是基于原来的底层数组
- 也就是说修改新的切片会修改原来的数组
- 不过记住一点，就算是这样，对应的 index 会因为其不同的切片对应不同位置

![error_loading](/gallery/2021-03-29-22-53-19.png)

## append 函数的说明

- 这个函数用于切片的扩容
  - 如果原来的切片可以容纳下要添加的元素，那么直接会给这个切片还没使用的元素进行赋值
  - 如果原来的切片不能容纳要添加的数据了，那么 append 会修改原来切片的长度，而且容量是翻倍的
- [使用实例](/posts/code/go/复合数据类型/append使用实例.go)

## 遍历切片

- 这个遍历的语法就是 for 循环，这个和之前说过的数组是差不多的
- 遍历这个切片可以结合 range 关键词
  - range 会返回两个数组
  - 第一是当前遍历到位置的 index
  - 第二个就是当前遍历到的元素数值，是副本
- [错误实例](/posts/code/go/复合数据类型/range创建的为副本.go)

```vim
- range创建的是每个元素的副本，而不是对元素的引用
- 如果使用range遍历到的数值指针来为作为指向切片的指针会出现错误
```

- 如果不需要 index 就可以直接使用 `_` 这个匿名变量来实现对数值的丢弃
- range 方法的遍历都是从切片的头开始的，所以如果要更多的操作，可以使用传统的 for

### 两个特殊的内置函数

- 下面两个函数可以处理数组，切片，通道
- len()
  - 返回切片的长度
- cap()
  - 返回切片的容量

## 限制容量

- 这个部分其实和之前的多维数组差不多
- 创建切片的时候可以使用第三个 index 选项
  - 可以控制新切片的容量
  - 不是增加切片的容量，而是限制容量
- 限制容量的主要作用还是为底层数组提供保护，以及更好的追加操作


```go
i 说明的是从原来的切片的哪一个index开始
j 说明的是从i的基础上想要 x 个数据的话 那么 j 就是 `j = i + x`
k 说明的是，被分割出来的切片的容量要是 y 的话 那么 k 就是 `k = i + k`

------------------------

但是新创建切片的容量不可以超过对应原来的源切片的容量
```

### 对于 append 方法潜在问题


- 所以潜在的问题就是可能会出现添加元素后的数组，以及源数组的之间的关联
- 因为如果切片共享底层数组的时候，修改"新"创建的切片可能会相互影响
- 所以我们期望的解决方式为，强制让新切片和原来的切片分离

---

- 具体操作为
  - 如果创建切片的时候设置的切片的容量和长度一样
  - 那么 append 会和原来的源切片分离开来，会独立一个单独的底层数组出来
  - [这里的具体说明可以结合这个代码来看](/posts/code/go/复合数据类型/append使用实例.go)
  - 所以这里的作用就是基于现有的切片来创建一个在合理范围之内的 长度 和 容量 的切片

## 多维切片

- 和之前的多维数组一样
  - 可以结合多个切片创建多维切片

```go
slice := [][]int{{10},{100,322}}

- 一个包含两个元素的外层切片
  - 每个元素包含一个内层的整型切片
  - 外层的切片包含两个元素，每个元素都是切片
```

## 传递切片给函数

- 这个是引用语义，也就是说，不管是传入整个数组，还是单独引用这个指针
- 都是会因为引用函数而修改原来的数组
- [测试实例](posts/code/go/复合数据类型/引用语义.go)

# 对于底层切片实现的一些知识

- 数组切片本质上就是底层数组的一个区间
- 可以用下面的结构体来解释

```go
type slice struct{
  first *T
  len int
  cap int
}
```

- 所以切片的内部就是指向数组的指针，所以可以改变所指向的数组元素不奇怪
- 数组切片本质上的赋值还是结构语义
  - 这里的意思就是直接传递切片的时候，slice 结构体还是赋值了一份
  - 但是因为结构体里面是包含底层数组的指针的，所以还是可以修改数值
  - [测试实例](posts/code/go/复合数据类型/引用语义.go)可以看出结构体默认是值语义的
