---
date: 2021-04-01 19:54:09
updated: 2021-04-01 19:54:09
title: go 方法
index_img: /gallery/2021-08-23-21-59-40.png
tags: 
  - Golang

categories:
  -  Golang

---

- [go 方法基本说明](#go-方法基本说明)
  - [方法的声明](#方法的声明)
    - [方法的命名原则](#方法的命名原则)
    - [一些局限和解决方法](#一些局限和解决方法)
    - [面向对象和面向过程的对比](#面向对象和面向过程的对比)
    - [方法和函数的区别](#方法和函数的区别)
    - [一些建议](#一些建议)
  - [工厂方法创建结构体](#工厂方法创建结构体)
    - [私有化结构体类型实现限制 new 初始化](#私有化结构体类型实现限制-new-初始化)
  - [基于指针对象的方法](#基于指针对象的方法)
  - [方法值和方法表达式](#方法值和方法表达式)
  - [方法和未导出字段](#方法和未导出字段)
  - [嵌入类型的方法继承](#嵌入类型的方法继承)
  - [多重继承](#多重继承)

# go 方法基本说明

- 方法简单来说就是基于某种数据类型变量上的函数
- 所以说方法是比较特殊的函数
- 上述的某种数据类型，除了接口，指针(可以是任何其他允许的数据类型的指针类型)，
  - 结构体类型
  - 函数类型
  - 基本数据类型
  - 数组别名类型
- 也就是说，要引用方法，那么对应的数据类型必须是具体的
- 一个数据类型，加上对应数据类型的方法，有点类似与面向对象编程的类
- 但是不同的是，go 语言有独特的包 机制，所以类型的代码和方法的代码可以存在与不同的源文件中，但是需要在同一个包中
- (关于包的知识我之后单独写个专题来说吧)

## 方法的声明

- 基本的定义格式如下

```go
func (receiver receiver_type) methodName(parameter_list)(return_value_list)  {
    ...
}
```

| 参数名字          | 解释                                                                                                                                                  |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| receiver          | receiver*type 类型的形参，用于下面的代码段的使用，如果不需要使用就使用`*`来代替                                                                       |
| receiver_type     | 是某个数据类型，之后调用这个方法的就是这个类型的实例                                                                                                  |
| methodName        | 对应 receiver_type 类型的 名字为 methodName 的方法                                                                                                    |
| parameter_list    | 这个是传递给这个方法的参数，注意区分 receiver `receiver_type_instance.methodName()`这一大段才算是真正的调用函数，而这里描述的就是传递给这个函数的参数 |
| return_value_list | 这个就是这个方法返回的数值，和函数的返回值是一致的                                                                                                    |

- 其实`receiver_type_instance` 有点类似于面向对象中的类的实例，然后用`.`来调用这个实例中的各种方法

### 方法的命名原则

- 因为方法是函数，所以不允许方法的重载，也就是说对于一个数据类型来说，只可以有一给定的方法
- 但是不同数据类型的方法，可以重载，也就是对于不同的数据类型，可以有同样名字的方法
- 对于别名类型不可以在原始类型上定义已经定义过的方法

### 一些局限和解决方法

- 局限
  - 因为类型和其方法必须在同一个包里面定义，
  - 但是如`int ,float`这些数据类型是在 go 语言的底层实现的除非修改 go 的源码
  - 上述例子就是为了说明，如果我们希望在其他包定义的数据类型之上添加我们想要的方法的时候会有问题
- 解决方法
  - 因为类型别名不受到这个规则限制
  - 所以可以把非本地包的数据类型在本地定义一个别名比如 `type loint int`
  - 或者作为匿名结构体字段嵌入到结构体里面
  - 那么就可以通过这个类型别名实现对非本地包数据结构添加方法

```go
type Giao struct{
    1 int
    2 int
}
func (receiver Giao) Adding() int {
    ...
}

```

### 面向对象和面向过程的对比

- 在 go 语言中，面向对象的面纱可以看的很清楚
- 具体可以比较下面的代码

```go
type Integer int

func (a Integer) Less(b Integer)  {
  return a<b
}

func Less(a Integer , b Integer)  {
  return a<b
}

a.Less(2)// ! 面向对象的调用
Less(a,a)// ! 面向过程的调用
```

### 方法和函数的区别

- 函数把变量作为参数`Function(arg1)`
- 方法在变量上被调用`Arg1.Method()`
- 当调用方法的数据结构为指针的时候方法可以改变对应的值和状态
- 当然上面的函数也可以做到(当传递的参数为指针的引用的时候)
- 定义方法的时候一定要有一个明显并且具体的 **类型** ，这个类型必须在和方法一样的包中声明

### 一些建议

- 不要把方法和结构体混合起来
- 类型和方法之间的关联由 对应的类型来建立

## 工厂方法创建结构体

- 在面向对象的编程中，可以通过构造子方法来实现工厂模式
  - 这里指的工厂其实就是个比方，比如说，这个是个加工厂，你给我原料，我帮你加工出来
  - 具体一点的例子就是，你传一个能存放指针的东西，我按照你的需求帮你把东西做好，然后你分配出来的位置，我把这个位置存放到你给我的值里面
- 有点类似与我以前写的 C 语言代码的意思

![error_loading](/gallery/2021-04-02-19-26-11.png)

- 下面是 Go 语言的具体例子
  - 下面的 `return &File{fd,name}` 
  - 查看实例占用了多少内存可以使用`size:=unsafe.Sizeof()`

```go
type File struct{ // ! 这里因为File是大写开头的所以这个类型是公有的，其他包可以调用
  fd int
  name string
} // ! 可以使用new来分配一个File结构体实例

func NewFile(fd int , name string) *File {// ! 接受结构体中的两个成员，
// 然后返回对应分配好实例的内存位置
  if fd < 0  {
    return nil
  }
  return &File{fd,name}
}
```

### 私有化结构体类型实现限制 new 初始化

- 这里的含义就是让声明的结构体私有化
- 达到的目的就是，不能在其他包里面使用 new 来声明这个结构体的实例
- 然后把工厂方法(初始化这个私有结构体的)指定为公有函数
- 最后就可以达到，只有这个工厂方法才可以实现对这个结构体的初始化
- 但是如果都是在同一个包，那么可以使用 new 初始化

```go
type file1 struct{// ! 这里因为file是大写开头的所以这个类型是私有的，其他包不可以调用
    fd int
  name string
}
func NewFile1(fd int , name string) *file1 {// ! 接受结构体中的两个成员，
// 然后返回对应分配好实例的内存位置
  if fd < 0  {
    return nil
  }
  return &File{fd,name}
}
// ! 这样就实现了，只有 NewFile1 对私有结构体 file1 的初始化
```

## 基于指针对象的方法

- 这里说明的是，接受者的类型为指针的情况
  - 具体含义就是`xxx.Method()`这里的 xxx 是某个数据类型的指针
- 使用这种形式来声明方法有几个好处
  - 在方法接收实例的时候，不用像值语义一样把整个实例复制一遍，减少了内存消耗
  - 这个因为是引用语义，所以方法中，可以直接修改接收到的实例指针指向的实例
- [这里是实例](/posts/code/go/函数/方法/指针对象.go)

- 一些使用摘要
  - 所以最好推荐，明显的指明这个是引用类型还是值类型
  - 因为 go 语言比较智能（选择器），会自动解析指针的不过最好还是能明显的写出来就写出来

```vim
结合第一列来看，可以分析出，具体是指针还是值类型
是由方法的接受者类型决定的
某个数据类型的指针和某个数据类型，
她们的方法是通用的，也就是说，她们的方法是不可以重名的
```

## 方法值和方法表达式

- 这个小结包含两个内容
  - 方法值
  - 方法表达式
- 方法值
  - 可以理解为 C 语言里面的指针函数
  - 比如有数据类型 T，T 有某个实例 x，T 类型有某个方法 M
  - 定义 `x.M` 这个值就是 M 方法的函数指针，可以把其赋值给一个变量
  - `Method1 := x.M`这样 Method1 可以被调用了
  - 通过`Method1(argv ...)`可以调用到 x.M 方法，然后后面的`argv...`就和正常调用`x.M(argv..)`提供的参数一样
  - 这种使用方法值调用方法的会隐含的传递 x 的值
  - [然后就是关于方法接受者类型是指针还是值影响不影响接受者数据的问题，这个部分参考这里](/posts/code/go/函数/方法/指针对象.go)

## 方法和未导出字段

- 这里主要说明的就是，要给指定的数据类型提供设置值和取出值的方法
- 然后具体方法接受者类型应该是指针，因为要修改对应的数值
- 然后设置和访问分别有个术语叫做 getter , setter
- [使用实例](/posts/code/go/函数/方法/未导出字段.go)

---

- 应该避免多个现场同时操作对象的字段值，因为这会导致线程之间产生竞争
- 而且极有可能返回意料之外的结果（无法得知哪个线程最后操作了字段的值）
- 为了安全的并发访问，go 语言提供了 sync 标准库
- 这个知识涉及到 goroutine 和 channel 并发访问对象的方式

![error_loading](/gallery/2021-04-03-17-59-10.png)

## 嵌入类型的方法继承

- 因为 go 语言不算是传统的面向对象的编程语言
- 所以 go 语言不支持在语言层面上的直接实现类的继承和亚类的实现

```go
- 但是因为go语言支持创建匿名结构体，所以可以把匿名结构体放入具名结构体中
- 这样就可以实现，具名结构体拥有匿名结构体的方法
```

- 上述和面向对象编程中类的继承等同
- 这个和 Python，语言中的 混入 类似

- [使用实例](/posts/code/go/函数/方法/具名嵌套匿名实现继承.go)

## 多重继承

- 这里其实算是 go 语言特殊之处了
- 因为大部分的面向对象语言中，都是不允许多重继承的
- 因为这回导致编译 器复杂，但是因为 go 语言没有类的概念
- 所谓继承不过就是结构体里面内嵌结构体
- 通过在某个子结构体嵌套必要的父级结构体
- 就可以简单的而实现多重继承，但是 go 中的多重继承不支持多重嵌套（父级结构体不支持再嵌套匿名结构体）
- 下面是个手机的例子
- 手机可以实现
  - 拍照
  - 打电话
- 但是拍照和打电话分别属于不同的类
- 然后使用手机结构体嵌套 拍照 和 打电话 这两个类
- 就实现了手机结构体对 拍照 和 打电话这两个类的多重继承
- [这里是实际例子](/posts/code/go/函数/方法/多重继承.go)
