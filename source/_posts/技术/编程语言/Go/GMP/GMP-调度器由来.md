---
date: 2021-04-14 11:03:55
updated: 2021-04-14 11:03:55
title: GMP 调度器由来
index_img: /gallery/2021-08-23-21-59-40.png
tags: 
  - Golang

categories:
  -  Golang

---

# GMP 调度器由来

## 早期单进程计算机

![error_loading](/gallery/2021-04-14-11-05-23.png)

- 所以会产出两个问题
  - 单一的执行流程,只能一个任务一个任务的处理
  - CPU 带来的浪费时间

## 如何宏观的执行?

- 时间片:就是分配给进程运行的单位时间

![error_loading](/gallery/2021-04-14-11-08-15.png)

- 缺点:从线程切换的时候会有上下文时间
  - 如果线程进程数量越大,那么切换成本越大
  - 多线程存在临界资源的问题,所以需要加锁,设计复杂

![error_loading](/gallery/2021-04-14-11-09-16.png)

- 内存消耗

![error_loading](/gallery/2021-04-14-11-11-10.png)

## 线程分析

- 一个线程分为
  - 用户态(应用逻辑)
  - 内核态(底层)

![error_loading](/gallery/2021-04-14-11-12-44.png)

- 如果能一分为二
  - 这样可以让两个线程处理不同的事情
  - 把用户线程绑定到内核线程
  - CPU 视野看内核进程

![error_loading](/gallery/2021-04-14-11-14-47.png)

- 所以协程的设计参考上面的逻辑
  - 使用调度器作为中间代理
  - 调度器和系统级别的线程继续绑定
  - 所以关于协程调度器和协程线程之间的关系存在 下面的比例模式

![error_loading](/gallery/2021-04-14-11-16-00.png)

### 1:N

- 缺点 : 如果一个协程出现阻塞,
- 因为多个协程绑定到的是一个线程
- 那么这个线程也会堵塞,所以其他没有堵塞的协程也会因此堵塞

![error_loading](/gallery/2021-04-14-11-18-14.png)

### 1:1

- 这样的设计没有意义,切换协程其实
- 在这个设计里还是线程级别,还是有消耗

![error_loading](/gallery/2021-04-14-11-20-59.png)

### N:M

- N 个线程绑定一个调度器
- 调度器绑定 M 个协程
- 所以这个结构的性能高低很大部分取决于调度器算法

![error_loading](/gallery/2021-04-14-11-22-36.png)

# Golang 对协程的处理

- 内存消耗修改

![error_loading](/gallery/2021-04-14-11-23-48.png)

# 总结

![error_loading](/gallery/2021-04-14-11-27-24.png)
