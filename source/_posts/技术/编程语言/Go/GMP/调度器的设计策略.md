---
date: 2021-04-14 19:39:00
updated: 2021-04-14 19:39:00
title: GMP-调度器设计策略
index_img: /gallery/2021-08-23-21-59-40.png
tags: 
  - Golang

categories:
  -  Golang

---

# GMP-调度器设计策略

- 主要就是为了处理分配 G(协程),和虚拟逻辑处理器(P)和 M(物理线程)的关系
- 这就包含了,如果 G 这个时候如果堵塞,应该如何处理各个 GMP

## 复用线程

- work stealing (偷取)

  - 如果有空闲的线程,这时候查找本地队列看是否有还没有运行的 G
  - 如果有的话,就把它转移到这个空闲的线程上运行
  - 如果偷不到就休眠/销毁这个线程

- 条件就是,一个空闲的线程,其他线程上有等待运行的 G

![error_loading](/gallery/2021-04-14-19-53-04.png)

- hand off
  - 如果在某个 P 上运行的 G1 进行阻塞操作了
  - 那么这个时候运行 G1 的逻辑处理器和这个线程脱离
  - 然后把现在挂起的这个 G1 放到这个线程上,然后自己新建一个新线程
    - 就 G1 的情况对这个线程睡眠或者销毁
  - 然后把这个 P 绑定到新创建的线程中

![error_loading](/gallery/2021-04-14-19-55-41.png)

## 利用并行

- GOMAXPROCS 来限定 P(逻辑处理器)的个数

## 抢占策略

- 原来的协程(co-routine)需要某个协程主动释放,其他协程才可以是使用 CPU 资源
- 但是现在(goroutine),每个 go 协程拥有平等地位,限定每个协程运行指定的时间,时间到了就必须强制释放
  - 这里可以参考操作系统处理线程(时间片)
  - 所以这个机制就是抢占是

![error_loading](/gallery/2021-04-14-19-59-36.png)

## 全局 G 队列

- 基于 work stealing
  - 如果**其他 P 的本地队列**已经没有待运行的 G 了
  - 那么空闲的 P 就会尝试去从全局队列里面去偷取带运行的 G

![error_loading](/gallery/2021-04-14-20-02-18.png)
